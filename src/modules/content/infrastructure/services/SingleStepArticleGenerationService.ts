import { PerplexityService } from './PerplexityService';
import { Result } from '../../shared/domain/types/Result';

export interface SingleStepGenerationRequest {
  feedItemContent: string;
  feedItemTitle: string;
  feedItemUrl?: string;
  customPrompts: {
    titlePrompt?: string;
    contentPrompt?: string;
    seoPrompt?: string;
  };
  settings?: {
    model?: string;
    temperature?: number;
    maxTokens?: number;
    language?: string;
    tone?: string;
    style?: string;
    targetAudience?: string;
  };
}

export interface SingleStepGenerationResult {
  title: string;
  content: string;
  metaDescription?: string;
  seoTags?: string[];
  statistics: {
    characterCount: number;
    wordCount: number;
    readingTime: number;
  };
  cost: number;
  generationTime: number;
  model: string;
}

export interface SingleStepGenerationError {
  message: string;
  details?: string;
}

/**
 * Unified single-step article generation service using only Perplexity
 * Replaces the complex 3-step workflow with a simple, unified approach
 */
export class SingleStepArticleGenerationService {
  private perplexityService: PerplexityService;

  constructor(perplexityApiKey: string) {
    this.perplexityService = new PerplexityService(perplexityApiKey);
  }

  async generateArticle(
    request: SingleStepGenerationRequest
  ): Promise<Result<SingleStepGenerationResult, SingleStepGenerationError>> {
    try {
      const startTime = Date.now();

      // Build unified prompt for Perplexity
      const unifiedPrompt = this.buildUnifiedPrompt(request);

      console.log('ðŸ¤– [SingleStep] Starting unified article generation...');
      console.log('ðŸ“ [SingleStep] Prompt preview:', unifiedPrompt.substring(0, 200) + '...');

      // Single call to Perplexity with all requirements
      const generationResult = await this.perplexityService.generateArticle({
        prompt: unifiedPrompt,
        model: request.settings?.model || 'sonar',
        sourceContent: request.feedItemContent,
        language: request.settings?.language || 'it',
        tone: request.settings?.tone || 'professionale',
        style: request.settings?.style || 'giornalistico',
        targetAudience: request.settings?.targetAudience || 'generale',
        targetWordCount: request.settings?.maxTokens ? Math.floor(request.settings.maxTokens * 0.75) : 800,
        parameters: {
          temperature: request.settings?.temperature || 0.7,
          maxTokens: request.settings?.maxTokens || 2000,
          model: request.settings?.model || 'sonar'
        },
        metadata: {
          requestId: `single-step-${Date.now()}`,
          context: {
            sourceUrl: request.feedItemUrl,
            originalTitle: request.feedItemTitle
          }
        }
      });

      if (generationResult.isFailure()) {
        console.error('âŒ [SingleStep] Perplexity generation failed:', generationResult.error);
        return Result.failure({
          message: 'Perplexity generation failed',
          details: generationResult.error.message
        });
      }

      const generated = generationResult.value;
      const generationTime = Date.now() - startTime;

      console.log('âœ… [SingleStep] Generation completed successfully!');
      console.log('ðŸ“Š [SingleStep] Stats:', {
        title: generated.title?.substring(0, 50) + '...',
        contentLength: generated.content?.length || 0,
        time: generationTime + 'ms',
        cost: generated.metadata?.cost || 0
      });

      // Extract SEO data from content if present
      const { metaDescription, seoTags } = this.extractSeoData(generated.content);

      const result: SingleStepGenerationResult = {
        title: generated.title || 'Generated Article',
        content: generated.content || 'Content generated by AutoGeorge AI.',
        metaDescription,
        seoTags,
        statistics: generated.statistics || {
          characterCount: generated.content?.length || 0,
          wordCount: Math.floor((generated.content?.length || 0) / 5),
          readingTime: Math.ceil((generated.content?.length || 0) / 1000)
        },
        cost: generated.metadata?.cost || 0,
        generationTime,
        model: generated.modelUsed || request.settings?.model || 'sonar'
      };

      return Result.success(result);

    } catch (error) {
      console.error('ðŸ’¥ [SingleStep] Generation service error:', error);
      return Result.failure({
        message: 'Article generation service error',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

  private buildUnifiedPrompt(request: SingleStepGenerationRequest): string {
    const {
      titlePrompt = 'Crea un titolo accattivante e SEO-friendly per questo articolo',
      contentPrompt = 'Scrivi un articolo completo e ben strutturato basato su questo contenuto',
      seoPrompt = 'Includi meta description, tags e parole chiave ottimizzate per i motori di ricerca'
    } = request.customPrompts;

    const settings = request.settings || {};

    return `
Genera un articolo completo in formato JSON con questa struttura esatta:

\`\`\`json
{
  "title": "...",
  "content": "...",
  "metaDescription": "...",
  "seoTags": ["tag1", "tag2", "tag3"]
}
\`\`\`

ISTRUZIONI DETTAGLIATE:

TITOLO:
${titlePrompt}

CONTENUTO:
${contentPrompt}

SEO E METADATA:
${seoPrompt}

CONTENUTO SORGENTE DA ELABORARE:
Titolo originale: ${request.feedItemTitle}
Contenuto: ${request.feedItemContent}
${request.feedItemUrl ? `URL originale: ${request.feedItemUrl}` : ''}

PARAMETRI DI STILE:
- Lingua: ${settings.language || 'italiano'}
- Tono: ${settings.tone || 'professionale'}
- Stile: ${settings.style || 'giornalistico'}
- Target audience: ${settings.targetAudience || 'generale'}
- Lunghezza target: ${settings.maxTokens ? Math.floor(settings.maxTokens * 0.75) : 800} parole

REQUISITI TECNICI:
- Rispondi SOLO con il JSON valido
- Non aggiungere testo prima o dopo il JSON
- Il contenuto deve essere formattato in Markdown
- La meta description deve essere max 160 caratteri
- Includi 3-5 tag SEO pertinenti
- L'articolo deve essere originale e ben strutturato

Genera l'articolo ora:`;
  }

  private extractSeoData(content: string): { metaDescription?: string; seoTags?: string[] } {
    // Try to extract SEO data from content if it contains structured info
    const metaMatch = content.match(/meta.{0,20}description[:\s]*([^.\n]{50,160})/i);
    const tagsMatch = content.match(/tags?[:\s]*([^.\n]+)/i);

    return {
      metaDescription: metaMatch?.[1]?.trim(),
      seoTags: tagsMatch?.[1]?.split(',').map(tag => tag.trim()).filter(Boolean)
    };
  }
}